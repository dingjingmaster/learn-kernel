# 汇编
  汇编语言是一种用于电子计算机、微处理器、微控制器或其他可编程期间的任何语言（也称符号语言）。在汇编中，用助记符代替机器指令的操作码，用地址(symbol) 或 符号(label) 代替指令或操作数的地址。特定的汇编语言与特定的机器语言指令集是一一对应的，不同平台之间不可互相移植。

## 汇编优点
  1. 程序是如何与操作系统、处理器、BIOS 交互的
  2. 数据是如何表示并存储在存储器与外部设备上的
  3. 处理器是如何访问与执行指令的，以及指令是如何访问与处理数据的
  4. 程序是如何访问外部设备的
  5. 能直接访问与硬件相关的存储器或I/O端口
  6. 能不受编译器限制，对生成的二进制代码进行完全的控制
  7. 能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁
  8. 能够根据特定的应用对代码做最佳的优化，提高运行速度
  9. 能够最大限度的发挥硬件的功能
  10. 用汇编编写的程序比高级程序编写的程序所要求存储空间与执行时间显著减少
  11. 汇编可以使程序员完成技术性非常强的任务
  12. 对于执行要求苛刻的代码，汇编才能胜任
  13. 常驻程序、中断服务例行程序几乎都是汇编开发的

## 汇编相关
  1. 汇编器: 汇编指令转为机器码的工具

## 汇编类型
  1. 微软汇编(MASM)
  2. Borland 公司的 Trubo 汇编 (TASM)
  3. GNU 汇编器(GAS)

## 汇编数制
    计算机里内存由数字组成，计算机以二进制格式来存储所有信息

### 十进制

### 二进制

### 十六进制

## 计算机内存和CPU的基础知识

### 内存
内存的基本单元是一个字节。一台32兆内存的电脑大概容纳 3200 万字节的信息。内存里的每一个字节通过一个唯一的数字来标识他们的地址。通常内存都是大块大块的使用，而不是单个字节。

| 名称 | 大小 |
| ----- | ----- |
| 1字节 | 4bit |
| word(字) | 2个字节 |
| double word(双字) | 4个字节 |
| quad word(四字) | 8个字节 |
| paragraph(一节) | 16个字节 |

字符通过数字来表示字符的字符编码来存储，常见的两个字符编码是: ASCII和Unicode，ASCII 由1个字节表示字符，Unicode由2个字节表示字符

### CPU
中央处理器(CPU)是执行指令的物理设备。指令可能要求他们使用的数据存储在一个 CPU 称为寄存器的特殊存储位置中。CPU 可以比访问内存更快的访问寄存器数据。但是，寄存器数量是有限的，所以程序必须只保存现在使用的数据到寄存器中。

各类 CPU 执行的指令组成了该 CPU 的机器语言。机器语言拥有比高级语言更基本的结构，机器语言指令被编码成未加工的数字，而不是友好的文本格式。为了更有效的运行，CPU 必须很快的解释一个指令的目的。机器语言就是为了这一目的设计的。一个其他语言写的程序必须转换为 CPU 本地机器语言，才能在电脑上运行。

编译器是一个将用户程序语言写的程序编译成特殊结构的电脑的机器语言的程序。通常，每一类CPU都有它自己唯一的机器语言。

电脑通过使用时钟来同步指令的操作，时钟脉冲在一个固定的频率(称为时钟频率)。电子计算机通过使用这一时钟来正确的执行他们的操作，就像节拍器来帮助你正确的节奏播放音乐

#### CPU 80X86系列
Intel 80X86家族的CPU都有一些普遍的特征，包括一些基本的机器语言。
- 8088, 8086: 这写CPU从变成的观点来说是完全相同的，他们是用在早期 PC 上的 CPU。他们提供一些 16 位的寄存器：AX、BX、CX、DX、SI、DI、BP、SP、CS、DS、SS、ES、IP、FLAGS。他们仅仅支持 1M 字节的内存，而且只能工作在实模式下。在这种模式下，一个程序可以访问任何内存地址，甚至其他程序的内存，这回使排除故障和保证安全变得非常困难。而且程序的内存需要分成段，每段的内存不能大于 64K。
- 80286: 这种 CPU 使用在 FAT 系列的 PC 机中。它在 8088/86 的基本机器语言中加入了一些新的指令。然而，它主要的新特性是 16 位保护模式。在这种模式下，它可以访问 16MB 字节的内存和通过通过阻止访问其他程序的内存来保护程序。可是，程序依然是分成不能大于 64K 的段。
- 80386: 这种 CPU 极大地增强了 80286 的性能。首先它扩展了许多寄存器来容纳 32 位数据(EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP、EIP)而且增加了两个新的16位寄存器：FS、GS；增加了一个新的32位保护模式。在这种模式下，它可以访问 4G 字节。程序同样需要分成段，但是现在每段大小同样可以到 4G。
- 80486/Pentium/Pentium Pro：这些 80X86 家族的成员增加了不多的新特性。他们主要是提高了指令执行的速度。Pentium MMX：这些处理器在 Pentium 基础上增加了 MMX 指令(多媒体扩展)。这些指令可以提高普通的图像操作的速率。
- Pentium II：它是拥有 MMX 指令的 Pentium 处理器。（Pentium III 本质上就是一个更快的 Pentium II）

#### 8086 16位寄存器
最初的 8086 CPU 提供 4 个 16 位通用寄存器：AX、BX、CX 和 DX。这些寄存器都可以分解成两个 6 位寄存器。例如：AX寄存器可以分解位 AH 和 AL 寄存器。AH 寄存器包含 AX 寄存器的高 8 位，AL 寄存器包含 AX 的低 8 位。

- SI 和 DI：这是两个 16 位指针寄存器，通常他们都是作为指针来使用的，但是在许多情况下也可以像通用寄存器一样使用。但是，他们不可以分解成 8 位寄存器
- BP 和 SP：这是两个 16 位堆栈寄存器，被称为基址寄存器和堆栈指针寄存器
- CS、DS、SS 和 ES: 这是 16 位段寄存器，它们指出程序不同部分所使用的内存。CS 代表代码段、DS 代表数据段、SS 代表堆栈段、ES 代表附加段。ES 作为一个暂时段寄存器来使用
- IP 和 CS：这是两个 16 位指令指针寄存器，一起使用来跟踪 CPU 下一条指令的地址。通常，
- FLAGS：这个 16 位寄存器存储了前面指令执行结果的重要信息。这些结果在寄存器里是以单个的位存储。例如：如果前面指令执行结果位0，2位为1，繁殖位0。并不是所有指令都修改 FLAGS 里的位

#### 80386 32位 寄存器
80386 及之后的处理器扩展了寄存器。例如：16位 AX 扩展成了 32 位 EAX。其他的扩展寄存器分别是：EBX、ECX、EDX、ESI、EDI，许多其他类型的寄存器也扩展了。BP 变成了 EBP、SP 变成了 ESP、FLAGS 变成了 EFLAGS、IP 变成了 EIP。但是，不同于指针寄存器和通用寄存器，在32位保护模式下只有这些寄存器的扩展形式被使用

在80386里段寄存器依然是16位的，这儿有了两个新的段寄存器：FS 和 GS，这块使用后续补全

## 计算机实模式和保护模式

### 实模式
实模式，也称实际地址模式，是所有x86兼容 CPU 下的一种操作模式。实模式的特点是 20bit 分段内存地址空间(精确到 1MB 的可寻址内存)以及对所有可寻址内存、I/O地址 和 外设硬件的无限制直接软件访问。实模式不支持内存保护、多任务处理、代码权限级别。

最早期的 8086 CPU 只有一种工作方式，那就是实模式，而且数据总线为16位，地址总线为20位，实模式下所有寄存器都是 16 位。而从 80286 开始就有了保护模式，从 80386 开始 CPU 数据总线和地址总线均为 32 位，而且寄存器都是 32 位。80386 以及现在的奔腾，酷睿等等 CPU 为了向前兼容都保留了实模式，有两种做法可以采纳：
    1. X86 CPU 在重置时都以实模式启动
    2. X86 CPU 以其他模式启动，从做系统起来后再模拟实模式
    
#### 实模式历史
1. 80286架构首次引入保护模式，允许硬件级别内存保护，但是使用这些新功能需要专为保护模式设计新的操作系统。X86 CPU 为了向后兼容，以 `实模式` 启动，为了运行 8086 和 8088 编写的操作系统。当前 x86 CPU(包括x86\_64 CPU)能够启动实模式操作系统，并且可以在不需要仿真或虚拟化的情况下运行几乎任何以前的 x86 编写的软件。
2. IBM 推出的PC BIOS 以实模式运行，DOS操作系统也是如此。现代版本的操作系统都是在启动时候将 CPU 切到保护模式，以后不再返回实模式，并且全程提供保护模式的所有好处。另外注意：80286 的保护模式更加原始；80386 的保护模式才是现代 32 位 x86 操作系统运行的模式。
    
#### 实模式寻址
8086 CPU 数据总线为 16 位，也就是一次最多取 `2^16 = 64KB` 数据，这个数据也揭示了实模式下为什么每个段最大只有 `64KB`。但是地址总线有 20 位，这样它的寻址能力应该是 `2^20 = 1MB`，这也就是实模式下 CPU 的最大寻址能力。既然他有 1MB 的寻址能力，为什么用 16 位的段寄存器表示呢？
这就引出了`分段`的概念，8086 CPU 将 1MB 存储空间分成许多逻辑段，每个段最大限长为 64KB（但不一定是 64KB）.这样每个存储单元就可以用"段基址 + 段内偏移地址" 表示段基址由 16 位段寄存器值左移 4 位表达，段内偏移表示相对于某个段起始位置的偏移量，比如：
```asm
SEG = 0X07C0
JMPI offset, #SEG
offset: MOV ax, cs
```

### 三种地址:
- 逻辑地址：即逻辑上的地址，实模式下由“段基址 + 段内偏移”组成；保护模式下由“段选择符 + 段内偏移”组成。
- 线性地址：逻辑地址经分段机制后就成线性地址，它是连续的；如果不启用分页，那么此线性地址即物理地址。
- 物理地址：线性地址经分页转换后就成了物理地址
    


















# 需要注意的问题

> 所有代码都是 x86(i386) 平台的

## 汇编语言三部分

- 数据段
  用于声明初始化数据或常量的数据段，在运行时，此数据不变。
  声明数据段的语法是:
  ```asm
  section .data
  ```

- bss段
  bss部分是用于声明变量，声明变量段的语法是:
  ```asm
  section .bss
  ```

- 文字部分
  文字部分用于保存实际的代码，开头必须的声明 `global` 告诉内核程序开始执行的地方
  声明文本部分的语法是:
  ```asm
  section .text
    global _start
  _start:
  ```

## 汇编语言语句

  汇编语言程序包括三个类型的语句:
  - 可执行指令或指令
    可执行指令或简单指示告诉的处理器该怎么做，每个指令+操作码最终生成机器语言指令
  - 汇编指令或伪操作
    汇编指令或伪指令告诉汇编有关汇编过程的各个方面。这些都是非可执行文件，并不会产生机器语言指令。
  - 宏
    基本上是一个文本替换机制

## 汇编语言语句的语法
  每行一个语句，每个语句语法如下:
  ```asm
  [label]  mnemonic  [operands]  [// 注释]
  ```
  方括号中的字段是可选的，基本指令有两部分组成，第一部分是要执行的指令(助记符)的名称和所述第二命令的操作数或参数
  例子:
  ```asm
  INC  COUNT            ; 增加内存数组大小
  MOV  TOTAL,  48       ; 将数字 48 移入 TOTAL 处
  ADD  AH,  BH          ; 寄存器 AH 和 BH 做加法
  AND  MASK1,  128      ; 
  ADD  MASKS,  10       ;
  MOV  AL,  10          ;
  ```
## 内存段
  对于分段存储模型的系统，内存划分为独立的段，引用指针位于段寄存器组，每个段包含指定类型的数据

## 处理器寄存器
  IA-32 架构中有10个32位和6个16位处理器寄存器，这些寄存器分为三大类：
  - 通用寄存器
    通用寄存器又进一步分为以下几类:
    - 数据寄存器
    - 指针寄存器
    - 索引寄存器
  - 控制寄存器
  - 段寄存器

### 数据寄存器
  4个32位数据寄存器用于算术、逻辑和其它操作，这些32位的寄存器可以用来在三个方面：
  1. 32位数据寄存器: EAX, EBX, ECX, EDX
  2. 下半部分32位寄存器可以作为4个16位数据寄存器
  3. 8个8位数据寄存器可以用作上面提到的4个16位寄存器的较低和较高的半部AH, AL, BH, BL, CH, CL, DH, DL
  AX - 主要是累加器，他被用于输入/输出和多数算术运算
  BX - 基址寄存器，他可用于索引寻址
  CX - 计数寄存器，存储循环计数迭代操作
  DX - 数据寄存器，可用来在输入/输出操作，也可用于与 AX、DX 涉及大的值的乘除法

### 指针寄存器
  指针寄存器是 32 位的 EIP、ESP 和 EBP 寄存器
  - IP(Instruction Yiibaier): 16位的IP寄存器，用来存储下一个要执行的指令编译地址。IP与CS寄存器给出了完整当前代码段中的当前指令地址(CS:IP)
  - SP(Stack Yiibaier): SP 寄存器的16位提供程序堆栈内的偏移值。SS和SP指向程序堆栈的当前位置的数据或地址(SS:SP)
  - BP(Base Yiibaier): 是16位的BP寄存器，主要是帮助将引用的参数变量传递到一个子程序。与SS寄存器中地址相结合，与BP的偏移得到参数的位置。

### 索引寄存器                       
  - SI: 字符串操作时候作为源
  - DI: 字符串操作时候作为目标

### 控制寄存器
  32位指令寄存器和32位标志寄存器组合被视为控制寄存器
  针对比较、数学运算、条件指令，用来测试这些状态、结果
  常见的标志位:
  - OF(Overflow Flag): 算是运算溢出标志
  - DF(Direction Flag): 决定向左或向右移动或比较字符串数据的方向。0:右移；1:左移
